#!/usr/bin/env Rscript

# Run quality assessment on microarray data prior to loading to Atlas, using
# the arrayQualityMetrics Bioconductor package. This script requires a
# tab-delimited annotation file mapping factor values to raw data filenames,
# created by arrayQC.pl.
#
# The script produces an HTML report (created by arrayQualityMetrics) and
# reports any assays that were found to be outliers by all three methods of
# outlier detection (heatmap, boxplot and MA plot).


# atlasArrayQC
# 	- Run arrayQualityMetrics for an experiment-array design.
# Arguments:
# 	- annotationFile : filename of annotation file containing mapping between
# 	factor values and raw data files.
# 	- exptType : affy, agil1 or agil2
# 	- exptAcc : experiment accession
# 	- arrayDesign : array design accession
# 	- outDir : directory to write quality report into
# 	- miRBaseFile : path to file with miRBase probe name mappings (0 for a
# 	non-miRNA experiment)
atlasArrayQC <- function(annotationFile, exptType, exptAcc, arrayDesign, outDir, miRBaseFile) {
	# Make a title for the report
	reportTitle <- paste("Microarray quality metrics report for", exptAcc, "on array design", arrayDesign)
	
	# The name of the column with factor values in the annotations file. This
	# will be "FactorValue" for one-colour experiments but will change to "Cy5"
	# for two-colour ones.  The values in this column are used to colour points
	# in the plots in the report.
	factorColName <- "FactorValue"

	# Read in raw data and add factor values to object created.
	# Affymetrix data
	if(exptType == "affy") {
   
 		dataSet <- affymetrixQC( annotationFile )
	}

	# Illumina data.
	# single channel data
	else if(exptType == "lumi") {

		dataSet <- illuminaQC( annotationFile )

	}
	# Agilent data.
	# One-colour or Two color Agilent data
	else if(exptType == "agil1" | exptType == "agil2") {

		dataSet <- agilentQC(annotationFile, exptType, miRBaseFile)

	}

	# Something we don't recognise.
	else { stop(paste("Can't handle", exptType, "experiments yet", sep=" ")) }

	# Load arrayQualityMetrics package
	library(arrayQualityMetrics)
	
	# Run quality metrics calculation
	# Store output in arrayQCdata
	#--------------------------------------------------
	# arrayQCdata <- arrayQualityMetrics(expressionset = dataSet, 
	# 					outdir = outDir,
	# 					force = TRUE,
	# 					do.logtransform = TRUE,
	# 					intgroup = factorColName,
	# 					spatial = FALSE,
	# 					reporttitle = reportTitle)
	#-------------------------------------------------- 
	
    ##########################
    # FIXME: Temporary workaround while arrayQualityMetrics package has a bug.
    # Courtesy of Mike Smith on the Bioconductor support site: https://support.bioconductor.org/p/76626/#76640
    preparedData <- prepdata(expressionset = dataSet, do.logtransform = TRUE, intgroup = factorColName)
    bo = aqm.boxplot(preparedData)
    de = aqm.density(preparedData)
    hm = aqm.heatmap(preparedData)
    pca = aqm.pca(preparedData)
    ma = aqm.maplot(preparedData)
    qm = list("Boxplot" = bo, "Density" = de, "Heatmap" = hm, "PCA" = pca, "MAplot" = ma)
    arrayQCdata <- aqm.writereport( 
        modules = qm, 
        arrayTable = preparedData$pData, 
        reporttitle = reportTitle, 
        outdir = outDir
    )
    # End temporary workaround
    ##########################
    
	# Next want to inspect the output of arrayQualityMetrics stored in the
	# arrayQCdata object. This object is a list, the element we are interested
	# in is "modules", which is also a list. It contains all the data displayed
	# in the HTML report generated by arrayQualityMetrics.
	
	# Put the indices of all outlier assays from the heatmap, boxplot and maplot into one vector.
    # FIXME: had to change "boxplot", "heatmap", and "maplot" to "Boxplot",
    # "Heatmap" and "MAplot" below -- check this still works with
    # arrayQualityMetrics package when we switch back.
	outlierIndices <- c(arrayQCdata$modules$Heatmap@outliers@which, arrayQCdata$modules$Boxplot@outliers@which, arrayQCdata$modules$MAplot@outliers@which)

	# Get the assay names corresponding to the indices above from the arrayTable data frame.
	outlierNames <- arrayQCdata$arrayTable$sampleNames[outlierIndices]

	# Now we have to count occurences of each assay name in the outlierNames
	# vector. Any that are in three times and were thus classified as outliers
	# by all three methods should be rejected.
	# This part uses sapply() to go through the unique assay names found in the
	# outlierNames vector, and use length() and which() to count how many times each
	# one appears.
	counts <- sapply(unique(outlierNames), function(x) {
		# len is the number of times the assay name (x) appears in the outlierNames
		# vector.
		len <- length(which(outlierNames == x))
		# return len
		len
	})

	# The counts variable returned above by sapply is a named vector. The names
	# are the assay names and the values are the number of times it appears in
	# the outlierNames vector.
	# If there are any, print them using cat() (so there aren't any [1] etc
	# added by print()) separated by tabs.
	if(length(which(counts == 3)) > 0) {
		cat("REJECTED ASSAYS:\t")
		cat(paste(names(which(counts == 3)), collapse="\t"))
		cat("\n")
	}
}

affymetrixQC <- function(annotationFile){

	# Read in the annotation file with factor values and corresponding raw data
	# files.
	annotations <- read.delim(annotationFile, header = TRUE, stringsAsFactors = FALSE)
	rownames(annotations) <- annotations$AssayName

	# Create Biobase AnnotatedDataFrame object with annotations.
	library(Biobase)
	annotDF <- new("AnnotatedDataFrame", annotations)

	# Load oligo package.
	library(oligo)

	# Read files into ExpressionFeatureSet object.
	dataSet <- try({read.celfiles(annotations$FileName)})
	if(class(dataSet) == "try-error") {
		return(dataSet)
	}

	# Add annotations to the object.
	phenoData(dataSet) <- annotDF

	return (dataSet)
}

illuminaQC <- function(annotationFile) {

	# Read in the annotation file with factor values and corresponding raw data
	# files.
	annotations <- read.delim(annotationFile, header = TRUE, stringsAsFactors = FALSE)
	rownames(annotations) <- annotations$AssayName

	# Create Biobase AnnotatedDataFrame object with annotations.
	library(Biobase)
	annotDF <- new("AnnotatedDataFrame", annotations)

	## make as assayNamees as dataframe
	samplesInfo <- data.frame(annotations$AssayName)

	# Load lumi package.
	library(lumi)

	# Read files into ExpressionFeatureSet object.
	dataSet <- try({lumiR.batch(fileList = unique(annotations$FileName), convertNuID = FALSE )})
	if(class(dataSet) == "try-error") {
		return(dataSet)
	}

	# Add annotations to the object.
	phenoData(dataSet) <- annotDF

	return (dataSet)

}

agilentQC <- function(annotationFile, exptType, miRBaseFile) {

	if(exptType == "agil1") {
		# Read in the annotation file with factor values and corresponding raw data
		# files.
		annotations <- read.delim(annotationFile, header = TRUE, stringsAsFactors = FALSE)
		rownames(annotations) <- annotations$AssayName

		# Create Biobase AnnotatedDataFrame object with annotations.
		library(Biobase)
		annotDF <- new("AnnotatedDataFrame", annotations)
	
		# Load limma package
		library(limma)
		
		# Read in the data to an "EListRaw" object.
		dataSet <- try({read.maimages(annotations$FileName, source="agilent", green.only=TRUE)})
		
		# If we have a miRBase mapping file, subset the data to only include
		# probes that are there.
		if(miRBaseFile != 0) {
			dataSet <- subsetProbes(dataSet, miRBaseFile)
		}
	
		# Make it into an "NChannelSet" object for arrayQualityMetrics to read.
		# For this need to put the expressions into an AssayData object.
		aData <- assayDataNew(storage.mode = "lockedEnvironment", exprs = dataSet$E)
		# Add the rownames from the annotations data frame (filenames) as the sample names.
		sampleNames(aData) <- rownames(annotations)
		# Create the NChannelSet object with the expressions and annotations.
		dataSet <- new("NChannelSet", assayData = aData, phenoData = annotDF)
		
		# Check things worked and return the error if not.
		if(class(dataSet) == "try-error") {
			return(dataSet)
		}
	}
	# Two-colour Agilent data
	else if(exptType == "agil2") {
		# Use the "Cy5" column from the annotations to colour points in the
		# report.
		factorColName <- "Cy5"

		# Load limma
		library(limma)

		# Create a "targets" data frame to show which samples are labelled with
		# which dye in the report.
		targets <- readTargets(annotationFile)
		
		# Read in the data to an "RGList" object.
		dataSet <- try({read.maimages(targets, source="agilent")})
		
		# Check things worked and return the error if not.
		if(class(dataSet) == "try-error") {
			return(dataSet)
		}
		
		# If we have a miRBase mapping file, subset the data to only include
		# probes that are there.
		if(miRBaseFile != 0) {
			dataSet <- subsetProbes(dataSet, miRBaseFile)
		}
	}

	return(dataSet)

}

# Copied this from normalizeOneExperiment.R but should prob take it out to a
# separate script to source.
# subsetProbes
#  - For microRNA, we only want to normalize using probesets that are mapped to
#  the latest release of miRBase (www.mirbase.org). Subset the data here.
# ARGUMENTS:
# 	- dataSet <- for now either EListRaw or RGList object.
# 	- miRBaseFile <- filename for miRBase mappings.
subsetProbes <- function(dataSet, miRBaseFile) {

	print(paste("There are", nrow(dataSet), "rows of data"))
	
	print(paste("Subsetting data for probes found in", miRBaseFile))

	# Read file with miRBase mappings into a data frame.
	miRBaseProbeMapping <- read.delim(miRBaseFile, stringsAsFactors = FALSE)
	
	# Probesets can be repeated; take unique set from design_element column in
	# miRBase mapping data frame.
	design_element <- unique(miRBaseProbeMapping$design_element)

	# Subset the data, taking only probesets from miRBase mapping file.
	# Agilent data is read in to one of two classes:
	# 	- "EListRaw" : 1-colour
	# 	- "RGList" : 2-colour
	if(class(dataSet) %in% c("EListRaw", "RGList")) { 
		
		# Subset dataSet using design_element column from miRBase mapping file.
		dataSet <- dataSet[which(dataSet$genes$ProbeName %in% design_element), ]
		
		# Check if we have any rows left after subsetting.
		if(nrow(dataSet) == 0) {
			# If not, that means no probe names matched any of the values in
			# the design_element column, so die.
			stop("No probes in raw data match values in design_element column of miRBase mapping file. Cannot proceed.")
		}
	}
	# If it's not an "ElistRaw" or "RGList" object we can't handle it (yet).
	else { print("Don't know how to subset for this type of array") }

	print(paste("After subsetting there are", nrow(dataSet), "rows remaining"))

	# TODO: add something here to subset for Affymetrix arrays.
	# Need to think about how to map probes to probesets because before
	# normalization probeset info is not available?
	
	return(dataSet)
}


# Run with arguments if there are any, otherwise don't do anything.
args <- commandArgs(TRUE)
if(length(args) > 0) {
	do.call(atlasArrayQC, as.list(args))
}
